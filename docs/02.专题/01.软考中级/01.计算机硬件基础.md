---
title: 计算机硬件基础
date: 2023-05-15 15:54:59
permalink: /pages/8e92bf/
categories:
  - 专题
  - 软考中级
tags:
  - 
---
# 计算机硬件基础

## 1. 计算机硬件基础

### 1.1. 数据的表示

#### 1.1.1. R进制（逢R进一）

二进制转10进制：

例：$(111000)_2$转化为十进制数。

位权展开：$2^5*1+2^4*1+2^3*1+2^2*0+2^1*0+2^0*0=56$

#### 1.1.2. 二进制，八进制，十六进制互转

二进制转八进制：从右往左起，每三位 二进制 转一位八进制。不足三位的在最左边加0补齐。

 八转二：对每一位八进制数转换为三位二进制表示。

二进制转十六进制：从右往左起，每四位 二进制 转一位十六进制。不足四位的在最左边加0补齐。

 十六转二：对**每一位十六进制数转换为四位二进制**表示。

例：

十进制0.25转二进制0.01，转十六进制，小数从左至右每四位一组，后面补00，为0.4。

#### 1.1.3. 原码，反码，补码

**原码**：最高位为符号位，0表示正数，1表示复数。其中数值0有+0与-0之分。其数值范围$-(2^{n-1}-1)$~$(2^{n-1}-1)$。8位时范围$-127$～$+127$

**反码**：正数的反码与原码相同；负数符号位不变，其余位取反。数值0有两种表示方式。数值范围$-(2^{n-1}-1)$~$(2^{n-1}-1)$。8位时范围$-127$～$+127$

**补码**：正数的补码与原码相同；负数的补码在反码基础上加1。数值0只有一种表示法，即：0000 0000。数值范围$-2^{n-1}$~$2^{n-1}-1$。8位时范围$-127$～$+127$，**适合数字加减运算**

**移码**：在补码基础上符号位取反，数值0只有一种表示法，即：1000 0000。

### 1.2. 逻辑运算

**与运算（＆）**：参加运算的两个数据，按二进制位进行 “与” 运算。 运算规则： 0&0=0; 0&1=0; 1&0=0; 1&1=1;

**或运算（|）**：参加运算的两个对象，按二进制位进行 ”或“ 运算。运算规则： 0|0 = 0; 0|1 = 1; 1|0 = 1; 1|1 = 1;

**非运算**：（）：参加运算的两个对象，按二进制位进行 “非” 运算。运算规则： 0=1 “非'0 等于 1; 1 =0 “非“1 等于 0

**异或运算（＾）**：参加运算的两个数据，按二进制位进行 “异或“ 运算。**同为0异为1**；

### 1.3. 计算机结构

![](https://xiaoliutalk.gitee.io/img/202204181822100.png)

**CPU**由运算器、控制器和寄存器组成。

**总线**：包括数据总线，地址总线，控制总线。总线分别传递对应的信息。
::: center
![](https://xiaoliutalk.gitee.io/img/主机.draw.svg)
:::

**运算器**：完成算术运算、逻辑运算和移位操作。主要部件算术逻辑单元（ALU）、累加器、标志寄存器、寄存器组、多路转换器和数据总线。

累加寄存器AC：暂存中间的结果。

**控制器**：实现指令读入、寄存、译码和执行过程有序的发出控制信号。主要部件：程序计数器PC、指令寄存器、指令译码器、时序产生器和信号发生器组成。 

程序计数器PC：保存指令所在的地址。

**寄存器**：暂存寻址和计算过程的信息。通常分为数据寄存器、地址寄存器、状态寄存器、控制寄存器。

### 1.4. 指令系统基础-寻址方式

**指令由操作码和操作数（地址码）组成。指令长度分为固定长度和可变长度两种。**

- **操作码**：要做什么样的操作，加减乘除。
- **地址码**：操作数的地址。

**寻址方式**：寻找操作数的方式。

- **立即寻址**：指令的地址码字段给出的不是操作数的地址而是操作数本身。其特点是访问一次存储器就可同时取出指令和操作数。

- **直接寻址（寄存器寻址）**：指令的地址码字段给出操作数所在存储单元地址（寄存器号）。

- **变址寻址**：操作数的地址由某个变址寄存器的内容和位移量相加。

- **间接寻址（寄存器间接寻址）**：操作数的地址是主存（寄存器）中的存储单元的内容。

- **相对寻址**：操作数的地址由指令寄存器的内容与位移量相加。

### 1.5. CISC（**复杂指令计算机**）和RISC（**简单指令计算机**）

**复杂指令计算机CISC：**

- 指令采用可变长指令格式，指令系统丰富，使用频率差别大，处理特殊任务效率高。

- 支持更多的数据类型和寻址方式。

- 指令系统对应的控制信号复杂，大多采用微程序控制方式。

- 高级语言实现简单，效率高

**简单指令计算机RISC**

- 采取定长指令格式，精简指令数量，使用频率接近。

- 采用寄存器操作，寻址方式少。

- 大部分指令都采用硬联控制实现。

- 优化编译程序来支持高级程序语言，需要较大的存储空间

### 1.6. 流水线

将一个操作分为多个可独立处理的子操作（如取指令、译码、取操作数、执行），每个子操作在一个专门的硬件站上执行，这样一个操作需要流水线上多个站的处理才能完成。
::: center
![](https://xiaoliutalk.gitee.io/img/202204121229537.svg)
:::

**流水线执行时间**：$T_k=(t_1+t_2+t_3)+(n-1)t_1$

最后的$t_1$ 为流水线周期，表示流水线执行时间最长的一段。

#### 6.1.1. 流水线-技术指标

- 吞吐率：$T_p=\frac {n}{T_k}$ 

  $n$为指令集数，$T_k$为流水线时间。

- 理论最大吞吐率：$t_p=\frac{1}{T}$ 

  $T$ 为流水线周期。

- 加速比：$S=\frac{T_s}{T_k}$

  $T_s$ 不使用流水线执行所需的时间。$T_k$ 为流水线时间。

- 效率：工作部件/总工作部件，具体需要看时间。

### 1.7. 存储系统

根据存储器在计算机系统中所起的作用，可分为**主存储器（内存）**， **辅助存储器（外存）**，**高速缓冲存储器（Cache）**，**控制存储器**等。为了解决对存储器要求容量大，速度快，成本低三者之间的矛盾，目前通常采用多级存储结构，即使用高速缓冲存储器、主存储器和外存储器。

#### 1.7.1. 存储器的储存方式

**顺序存取**（磁带）**直接存取**（硬盘）**随机存取**（内存）**相关存取**（Cache）

#### 1.7.2. 主存储器

主存储器又称**内存**或**主存**，由一片或多片存储芯片配以控制电路组成的。

按照存取方式分类，可分为**随机存储器RAM**（**断电数据丢失**，如内存）、**只读存储器ROM**（断电数据不丢失）
主存储器（内存）采用随机存取方式，需要对每个存储单元进行编址。

存储器总容量：$W＊B$

**W**：储存单元（word）的数量。

**B**：每个 word 由多少位（bit）组成。

主存储器（内存）采用**随机存取**方式，需要对每个存储单元进行编址。通常以word为单位进行标识，即每一个**字**一个地址，通常采用16进制表示。

存储容量相关术语：

**位**：用 bit 表示。— 个二进制表示1个bit。
**字节**：用 B 表示。Byte。1B = 8bit。
**字**： 表示CPU—次处理的二进制位数，通常为字节的整数倍。对应的字节长有： 8/16/32/64bit。

#### 1.7.3. 高速缓冲存储器（Cache）

高速存取指令和数据，存取速度快，但存储容量小。高速缓存是为了解决CPU 和主存速率不匹配，提高CPU 工作效率。

**命中率**：访问信息的概率。

例：假如执行过程中对Cache的访问次数为 $N1$ 和对主存访问为 $N2$ ，则Cache命中率为 $H＝\frac {N1}{(N1+N2)}$

平均存取时间：Cache的访问周期时间是T1、主存储器的访问周期时间是T2、命中率为H、则平均存取时间为：

$T＝H*T1+（1－H）T2$

**Cache 映射机制**：直接映射、全相联映射、组相联映射
**Cache 淘汰算法**：先进先出算法（FIFO）、最近最少使用算法、随机算法

#### 1.7.4. 外存储器

外存／辅存，存放系统程序和大型数据文件及数据库，存储容量大，存取速度慢，单位成本低。

### 1.8. 磁盘阵列（RAID）

**RAID 0**：需要两块以上磁盘，每个磁盘划分不同的区块，数据采用交叉存取和井行传输。这种磁盘**利用率高(100%）**，读写速度最快，但由于没有数据差错控制，因此很容易发生数据错误。

**RAID 1**：磁盘成对组成，每个工作磁盘均有对应的映射，上面保存着与工作盘完全相同的数据，具有最高的安全性，但**磁盘利用率为50%**。

**RAID 3**：把**奇偶校验码**（只能查错不能纠错） 存在—个独立的磁盘，如果— 个磁盘失效，其上的数据可以通过其他盘上数据进行异或运算得到，读盘速度快，但写入速度慢。适用于图像处理等要求高吞吐率的场合，磁盘利用率：$\frac {n-1}{n}$ 

**RAID 5**：各块磁盘进行**条带化分割**，相同的条带进行分布式**奇偶校验**，检验数据平均分配在每—块硬盘上。磁盘利用率：$\frac {n-1}{n}$（**n为RAID组内成员盘个数**） **允许坏盘数量为1**。

**RAID 6**：存在两组独立的分散在不同条带上的校验数据   允许两块数据盘故障，并可通过校验数据计算得到故障硬盘中的数据。磁盘利用率：$\frac {n-2}{n}$（**n为RAID组内成员盘个数**） 。**允许坏盘数量为2**。

**组合RAID 技术（RAID10）**：RAID1+0 以及 RAID 0+1, 是RAID 0 与 RAID 1 组合形式，它提供 RAID 1 的安全保障同时提供 RAID 0 近似的访问速度。RAID 1+0 拥有更高的数据安全性在企业中更常使用。**磁盘利用率为50%**。**允许坏盘数量为n/2**。

#### 1.8.1. RAID2.0

传统RAID是基于一块块硬盘来做RAID，现在的硬盘存储空间多则10T，这要是坏了一块，重构10T的数据耗时不说，还影响同RAID组中其他硬盘的工作效率。这时RAID2.0诞生了。

RAID2.0不再以硬盘为单位做RAID，而是先将同RAID组中的所有硬盘切块，基于块来构建RAID组。

RAID2.0+底层是RAID2.0，但是上层（LUN层）又做了精细化分。原理如下：

![](https://xiaoliutalk.gitee.io/img/202204291434179.png)

大致可以看到，底层先对硬盘切条形成CK，把各个硬盘（必须是同一类型的硬盘）的条放在一起形成CKG。再对CKG横向切割（为了让数据分散到每一块硬盘中，纵向是相同硬盘，横向是不同硬盘）。再把切割完的数据块组成Extent，把多个Extent组成LUN，最后映射给主机使用。

同时可以看到热备盘也由原来的一块实体盘改成了由多个不同硬盘组成的块来充当热备盘。

**RAID2.0优势**：

- **自动负载均衡**。降低存储系统整体故障率。
- **快速精简重构**。降低了双盘失效率和数据丢失风险。
- **故障自检自愈**。保障系统可靠性。
- **虚拟池化设计**。降低存储规划管理难度。

### 1.9. 系统可靠性

串联系统：比如CPU无法正常工作了，那么内存也是无法正常工作，这个就叫做串联系统。

串联系统的可靠性： $R = R_1* R_2 * …… * R_n$

其中 $R_n$ 表示各个部件不能正常工作的概率。

并行系统：有几条内存同时工作，这个就叫做并行系统。

并行系统的可靠性： $R = 1-(1-R_1)* (1-R_2) * …… * (1-R_n)$
---
title: InnoDB记录存储结构-行
date: 2022-12-16 14:31:41
permalink: /pages/749fc5/
categories:
  - 《MySQL 是怎样运行的：从根儿上理解 MySQL》
tags:
  - 
---
# InnoDB记录存储结构-行

## 1. InnoDB行格式

行格式（row_format），就是一条记录的存储结构。

InnoDB 提供了 4 种行格式，分别是 **Redundant**、**Compact**、**Dynamic**和 **Compressed** 行格式。

- **Redundant**：是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。不是一种紧凑的行格式。
- **Compact**：是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 **MySQL 5.1** 版本之后，行格式默认设置成 Compact。
- **Dynamic**：和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 **MySQL 5.7** 版本之后，默认使用 Dynamic 行格式。

Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次重点介绍 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。

## 2. 指定行格式的语法

我们可以在创建或修改表的语句中指定`行格式`：

```sql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称;
ALTER TABLE 表名 ROW_FORMAT=行格式名称;
```

比如我们在`xiaohaizi`数据库里创建一个演示用的表`record_format_demo`，可以这样指定它的`行格式`：

```sql
CREATE TABLE record_format_demo (
    c1 VARCHAR(10),
    c2 VARCHAR(10) NOT NULL,
    c3 CHAR(10),
    c4 VARCHAR(10)
) CHARSET=ascii ROW_FORMAT=COMPACT;
```

我们现在向这个表中插入两条记录：

```sql
INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
```

现在表中的记录就是这个样子的：

```sql
mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)
```

## 3. COMPACT行格式

![](https://static.xiaoliutalk.cn/img/202212121433317.jpg)

一条完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分。

### 3.1. 记录的额外信息

分别是`变长字段长度列表`、`NULL值列表`和`记录头信息`。

#### 3.1.1. 变长字段长度列表

`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，这些都是`变长字段`。

在`Compact`行格式中，把所有**变长字段的真实数据占用的字节长度**都存放在变长字段长度列表，各变长字段真实数据占用的字节数按照列的顺序**逆序**存放。

我们拿`record_format_demo`表中的第一条记录来举个例子。因为`record_format_demo`表的`c1`、`c2`、`c4`列都是`VARCHAR(10)`类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为`record_format_demo`表中的各个列都使用的是`ascii`字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：

| 列名 | 存储内容 | 真实数据占用的字节数（十进制表示） | 真实数据占用的字节数（十六进制表示） |
| ---- | -------- | ---------------------------------- | ------------------------------------ |
| c1   | 'aaaa'   | 4                                  | 0x04                                 |
| c2   | 'bbb'    | 3                                  | 0x03                                 |
| c4   | 'd'      | 1                                  | 0x01                                 |

把这个**逆序**存放的字节串组成的`变长字段长度列表`填入上边的示意图中的效果就是：

![](https://static.xiaoliutalk.cn/img/202212121504877.jpg)

#### 3.1.2. NULL值列表

我们知道表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以 `compact`行格式把这些值为 NULL 的列存储到 NULL值列表中。

如果表中没有允许存储 _**NULL**_ 的列，则 _NULL值列表_ 也不存在了，在设计数据库表的时候，通常都是建议将字段设置为 **NOT NULL**，这样可以节省 **1 字节**的空间。

**二进制位**按照列的顺序**逆序排列**，二进制位表示的意义如下：

*   二进制位的值为`1`时，代表该列的值为`NULL`。
*   二进制位的值为`0`时，代表该列的值不为`NULL`。

`MySQL`规定`NULL值列表`必须用**整数个字节的位（1字节8位）**表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`。如果一个表中有9个允许为`NULL`，那这个记录的`NULL`值列表部分就需要2个字节来表示了。

因为表`record_format_demo`有3个值允许为`NULL`的列，所以这3个列和二进制位的对应关系就是这样：

![](https://static.xiaoliutalk.cn/img/202212121507372.jpg)

**二进制位**按照列的顺序**逆序**排列。

表`record_format_demo`只有3个值允许为`NULL`的列，对应3个二进制位，不足一个字节，所以在字节的高位补`0`，效果就是这样：

![](https://static.xiaoliutalk.cn/img/202212121510404.jpg)

只有`c1`、`c3`、`c4`这3个列允许存储`NULL`值，所以所有记录的`NULL值列表`只需要一个字节。

*   对于第一条记录来说，`c1`、`c3`、`c4`这3个列的值都不为`NULL`，所以它们对应的二进制位都是`0`：
    
    ![](https://static.xiaoliutalk.cn/img/202212121513008.jpg)
    
*   对于第二条记录来说，`c1`、`c3`、`c4`这3个列中`c3`和`c4`的值都为`NULL`，所以这3个列对应的二进制位的情况就是：
    
    ![](https://static.xiaoliutalk.cn/img/202212121515095.jpg)
    

这两条记录在填充了`NULL值列表`后的示意图，`NULL值列表`采用16进制进行存储：

![](https://static.xiaoliutalk.cn/img/202212121516131.jpg)

#### 3.1.3. 记录头信息

除了`变长字段长度列表`、`NULL值列表`之外，还有一个用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

![](https://static.xiaoliutalk.cn/img/202212121517689.jpg)

这些二进制位代表的详细信息如下表：

| 名称         | 大小（单位：bit） | 描述                                                         |
| ------------ | ----------------- | ------------------------------------------------------------ |
| 预留位1      | 1                 | 没有使用                                                     |
| 预留位2      | 1                 | 没有使用                                                     |
| delete_mask  | 1                 | 标记该记录是否被删除                                         |
| min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| n_owned      | 4                 | 表示当前记录拥有的记录数                                     |
| heap_no      | 13                | 表示当前记录在记录堆的位置信息                               |
| record_type  | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置                                     |

### 3.2. 记录的真实数据

对于`record_format_demo`表来说，`记录的真实数据`除了`c1`、`c2`、`c3`、`c4`这几个我们自己定义的列的数据以外，`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

| 列名                              | 是否必须 | 占用空间 | 描述                   |
| --------------------------------- | -------- | -------- | ---------------------- |
| **DB\_ROW\_ID**（row_id）         | 否       | 6字节    | 行ID，唯一标识一条记录 |
| **DB\_TRX\_ID**（transaction_id） | 是       | 6字节    | 事务ID                 |
| **DB\_ROLL\_PTR**（roll_pointer） | 是       | 7字节    | 回滚指针               |

这里需要提一下`InnoDB`表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 _**transaction\_id**_ 和 _**roll\_pointer**_ 这两个列，但是 _**row\_id**_ 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

因为表`record_format_demo`并没有定义主键，所以`MySQL`服务器会为每条记录增加上述的3个列。现在看一下加上`记录的真实数据`的两个记录长什么样吧：

![](https://static.xiaoliutalk.cn/img/202212121549198.jpg)

看这个图的时候我们需要注意几点：

1.  表`record_format_demo`使用的是`ascii`字符集，所以`0x61616161`就表示字符串`'aaaa'`，`0x626262`就表示字符串`'bbb'`，以此类推。
    
2.  注意第1条记录中`c3`列的值，它是`CHAR(10)`类型的，它实际存储的字符串是：`'cc'`，而`ascii`字符集中的字节表示是`'0x6363'`，虽然表示这个字符串只占用了2个字节，但整个`c3`列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在`ascii`字符集的表示就是`0x20`。
    
3.  注意第2条记录中`c3`和`c4`列的值都为`NULL`**，它们被存储在了前边的**NULL值列表处。
    

### 3.3. CHAR(M)列的存储格式

在`Compact`行格式下只会把**变长类型**的列的长度逆序存到`变长字段长度列表`中，因为我们的`record_format_demo`表采用的是**ascii**字符集，这个字符集是一个定长字符集，如果采用变长的字符集如**gbk**，**utf8**等等，`c3`列的长度也会被存储到`变长字段长度列表`中。

比如我们修改一下`record_format_demo`表的字符集：

```sql
ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;
```

修改该列字符集后记录的`变长字段长度列表`也发生了变化，如图：

![](https://static.xiaoliutalk.cn/img/202212121651355.jpg)

对于 **CHAR(M)** 类型的列来说：

- 当列采用的是**定长字符集**时，该列占用的字节数**不会被加到变长字段长度列表**，
- 而如果采用**变长字符集**时，该列占用的字节数也**会被加到变长字段长度列表**。

另外有一点还需要注意，变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求。比方说对于使用`utf8`字符集的`CHAR(10)`的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用`10`个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间称为所谓的碎片。（这里你感受到设计`Compact`行格式的大叔既想节省存储空间，又不想更新`CHAR(M)`类型的列产生碎片时的纠结心情了吧。）

## 4. 行溢出数据

### 4.1. VARCHAR(M)最多能存储的数据

我们知道对于`VARCHAR(M)`类型的列最多可以占用`65535`个字节。如果我们使用`ascii`字符集的话，一个字符就代表一个字节，我们看看`VARCHAR(65535)`是否可用：

```sql
mysql> CREATE TABLE varchar_size_demo(
    ->     c VARCHAR(65535)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
```

`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节。所以`MySQL`服务器建议我们把存储类型改为`TEXT`或者`BLOB`的类型。

这个`65535`个字节除了列本身的数据之外，还包括一些其他的数据（`storage overhead`），比如说我们为了存储一个`VARCHAR(M)`类型的列，其实需要占用3部分存储空间：

*   真实数据
*   真实数据占用字节的长度
*   `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间（1字节）

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度可能占用2个字节，`NULL`值标识需要占用1个字节：

```sql
mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果`VARCHAR`类型的列有`NOT NULL`属性，那最多只能存储`65533`个字节的数据，因为真实数据的长度可能占用2个字节，不需要`NULL`值标识：

```sql
mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65533) NOT NULL
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那会怎么样呢？来看一下：

```sql
mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=gbk ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 32767); use BLOB or TEXT instead

mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=utf8 ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 21845); use BLOB or TEXT instead
```

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。

- `gbk`字符集表示一个字符最多需要`2`个字符，在字段允许为NULL的情况下，计算最多能存储多少真实数据的公式为`(65535-2-1)÷2=32766`，字段不允许为NULL的情况下，公式为`(65535-2)÷2=32766.5`。
- `utf8`字符集表示一个字符最多需要`3`个字符，在字段允许为NULL的情况下，计算最多能存储多少真实数据的公式为`(65535-2-1)÷3=21844`，字段不允许为NULL的情况下，公式为`(65535-2)÷3=21844.333`。
- `utf8mb4`字符集表示一个字符最多需要`4`个字符，在字段允许为NULL的情况下，计算最多能存储多少真实数据的公式为`(65535-2-1)÷4=16383`，字段不允许为NULL的情况下，公式为`(65535-2-1)÷4=16383.25`。

### 4.2. 记录中的数据太多产生的溢出

我们以`ascii`字符集下的`varchar_size_demo`表为例，插入一条记录：

```sql
CREATE TABLE varchar_size_demo(
      c VARCHAR(65532)
) CHARSET=ascii ROW_FORMAT=Compact;
-- REPEAT('a', 65532)表示生成一个把字符`'a'`重复`65532`次的字符串
INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
```

`MySQL`中磁盘和内存交互的基本单位是`页`，而一个页的大小一般是`16384`字节，而一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的情况。

在`Compact`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址（包括其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。

对于`Compact`行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`768`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`，存储超出`768`字节的那些页面也被称为`溢出页`。画一个简图就是这样：

![](https://static.xiaoliutalk.cn/img/202212161009087.jpg)

最后需要注意的是，不只是 _**VARCHAR(M)**_ 类型的列，其他的 _**TEXT**_、_**BLOB**_ 类型的列在存储数据非常多的时候也会发生`行溢出`。

### 4.3. 行溢出的临界点

`MySQL`中规定**一个页中至少存放两行记录**。

以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

*   **每个页存储额外的信息**需要`136`个字节的空间，其他的空间都可以被用来存储记录。
    
*   **每个记录需要的额外信息**是`27`字节。
    
    这27个字节包括下边这些部分：
    
    *   2个字节用于存储真实数据的长度
    *   1个字节用于存储列是否是NULL值
    *   5个字节大小的头信息
    *   6个字节的`row_id`列
    *   6个字节的`transaction_id`列
    *   7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，那么发生`行溢出`现象时需要满足这个式子：

$$136 + 2×(27 + n) > 16384$$

求解这个式子得出的解是：`n > 8098`。也就是说如果一个列中存储的数据不大于`8098`个字节，那就不会发生`行溢出`，否则就会发生`行溢出`。不过这个`8098`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们想一个行中存储了很大的数据时，可能发生`行溢出`的现象。

## 5. Dynamic和Compressed行格式

下边要介绍另外两个行格式，`Dynamic`和`Compressed`行格式，我现在使用的`MySQL`版本是`5.7`，它的默认行格式就是`Dynamic`，这俩行格式和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![](https://static.xiaoliutalk.cn/img/202212160949794.jpg)

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

### CHAR(M)中的M值过大的情况

`CHAR(M)`类型的列可以存储的最大字节长度等于该列使用的字符集表示一个字符需要的最大字节数和`M`的乘积。如果某个列使用的是`CHAR(M)`类型，并且它可以存储的最大字节长度超过`768`字节，那么不论我们使用的是上述4种的哪种行格式，`InnoDB`都会把该列当成变长字段看待。比方说采用`utf8mb4`的`CHAR(255)`类型的列将会被当作变长字段看待，因为`4×255 > 768`。

